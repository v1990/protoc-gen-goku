// Code generated by protoc-gen-goku. DO NOT EDIT.
// source: google/protobuf/descriptor.proto

package descriptors

import (
	"google.golang.org/protobuf/types/descriptorpb"
)

// ===================================================================
// Options
//
// Each of the definitions above may have "options" attached.  These are
// just annotations which may cause code to be generated slightly differently
// or may contain hints for code that manipulates protocol messages.
//
// Clients may define custom options as extensions of the *Options messages.
// These extensions may not yet be known at parsing time, so the parser cannot
// store the values in them.  Instead it stores them in a field in the *Options
// message called uninterpreted_option. This field must have the same name
// across all *Options messages. We then use this field to populate the
// extensions when we build a descriptor, at which point all protos have been
// parsed and so all extensions are known.
//
// Extension numbers for custom options may be chosen as follows:
//  For options which will only be used within a single application or
// organization, or for experimental options, use field numbers 50000
// through 99999.  It is up to you to ensure that you do not use the
// same number for multiple options.
//  For options which will be published and used publicly by multiple
// independent entities, e-mail protobuf-global-extension-registry@google.com
// to reserve extension numbers. Simply provide your project name (e.g.
// Objective-C plugin) and your project website (if available) -- there's no
// need to explain how you intend to use them. Usually you only need one
// extension number. You can declare multiple options with only one extension
// number by putting them in a sub-message. See the Custom Options section of
// the docs for examples:
// https://developers.google.com/protocol-buffers/docs/proto#options
// If this turns out to be popular, a web service will be set up
// to automatically assign option numbers.
//   See: descriptorpb.FileOptions
type FileOptions struct {
	common

	pb *descriptorpb.FileOptions

	uninterpreted_option []*UninterpretedOption
}

func newFileOptions(desc *descriptorpb.FileOptions) *FileOptions {
	t := new(FileOptions)
	t.pb = desc

	t.setDescriptor(t)

	return t
}

// Sets the Java package where classes generated from this .proto will be
// placed.  By default, the proto package is used, but this is often
// inappropriate because proto packages do not normally start with backwards
// domain names.
//   See descriptorpb.FileOptions FileOptions.JavaPackage
//   SourceCodeInfo.Location.Path: [4 10 2 0]
//   proto info: {}
func (t *FileOptions) GetJavaPackage() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetJavaPackage()

}

func (t *FileOptions) JavaPackage() string {
	return t.GetJavaPackage()
}

// If set, all the classes from the .proto file are wrapped in a single
// outer class with the given name.  This applies to both Proto1
// (equivalent to the old "--one_java_file" option) and Proto2 (where
// a .proto always translates to a single class, but you may want to
// explicitly choose the class name).
//   See descriptorpb.FileOptions FileOptions.JavaOuterClassname
//   SourceCodeInfo.Location.Path: [4 10 2 1]
//   proto info: {}
func (t *FileOptions) GetJavaOuterClassname() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetJavaOuterClassname()

}

func (t *FileOptions) JavaOuterClassname() string {
	return t.GetJavaOuterClassname()
}

// If set true, then the Java code generator will generate a separate .java
// file for each top-level message, enum, and service defined in the .proto
// file.  Thus, these types will *not* be nested inside the outer class
// named by java_outer_classname.  However, the outer class will still be
// generated to contain the file's getDescriptor() method as well as any
// top-level extensions defined in the file.
//   See descriptorpb.FileOptions FileOptions.JavaMultipleFiles
//   SourceCodeInfo.Location.Path: [4 10 2 2]
//   proto info: {}
func (t *FileOptions) GetJavaMultipleFiles() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetJavaMultipleFiles()

}

func (t *FileOptions) JavaMultipleFiles() bool {
	return t.GetJavaMultipleFiles()
}

// This option does nothing.
//   See descriptorpb.FileOptions FileOptions.JavaGenerateEqualsAndHash
//   SourceCodeInfo.Location.Path: [4 10 2 3]
//   proto info: {}
func (t *FileOptions) GetJavaGenerateEqualsAndHash() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetJavaGenerateEqualsAndHash()

}

func (t *FileOptions) JavaGenerateEqualsAndHash() bool {
	return t.GetJavaGenerateEqualsAndHash()
}

// If set true, then the Java2 code generator will generate code that
// throws an exception whenever an attempt is made to assign a non-UTF-8
// byte sequence to a string field.
// Message reflection will do the same.
// However, an extension field still accepts non-UTF-8 byte sequences.
// This option has no effect on when used with the lite runtime.
//   See descriptorpb.FileOptions FileOptions.JavaStringCheckUtf8
//   SourceCodeInfo.Location.Path: [4 10 2 4]
//   proto info: {}
func (t *FileOptions) GetJavaStringCheckUtf8() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetJavaStringCheckUtf8()

}

func (t *FileOptions) JavaStringCheckUtf8() bool {
	return t.GetJavaStringCheckUtf8()
}

//   See descriptorpb.FileOptions FileOptions.OptimizeFor
//   SourceCodeInfo.Location.Path: [4 10 2 5]
//   proto info: {}
func (t *FileOptions) GetOptimizeFor() (ret FileOptions_OptimizeMode) {
	if t.Empty() {
		return
	}

	return t.pb.GetOptimizeFor()

}

func (t *FileOptions) OptimizeFor() FileOptions_OptimizeMode {
	return t.GetOptimizeFor()
}

// Sets the Go package where structs generated from this .proto will be
// placed. If omitted, the Go package will be derived from the following:
// - The basename of the package import path, if provided.
// - Otherwise, the package statement in the .proto file, if present.
// - Otherwise, the basename of the .proto file, without extension.
//   See descriptorpb.FileOptions FileOptions.GoPackage
//   SourceCodeInfo.Location.Path: [4 10 2 6]
//   proto info: {}
func (t *FileOptions) GetGoPackage() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetGoPackage()

}

func (t *FileOptions) GoPackage() string {
	return t.GetGoPackage()
}

// Should generic services be generated in each language?  "Generic" services
// are not specific to any particular RPC system.  They are generated by the
// main code generators in each language (without additional plugins).
// Generic services were the only kind of service generation supported by
// early versions of google.protobuf.
//
// Generic services are now considered deprecated in favor of using plugins
// that generate code specific to your particular RPC system.  Therefore,
// these default to false.  Old code which depends on generic services should
// explicitly set them to true.
//   See descriptorpb.FileOptions FileOptions.CcGenericServices
//   SourceCodeInfo.Location.Path: [4 10 2 7]
//   proto info: {}
func (t *FileOptions) GetCcGenericServices() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetCcGenericServices()

}

func (t *FileOptions) CcGenericServices() bool {
	return t.GetCcGenericServices()
}

//   See descriptorpb.FileOptions FileOptions.JavaGenericServices
//   SourceCodeInfo.Location.Path: [4 10 2 8]
//   proto info: {}
func (t *FileOptions) GetJavaGenericServices() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetJavaGenericServices()

}

func (t *FileOptions) JavaGenericServices() bool {
	return t.GetJavaGenericServices()
}

//   See descriptorpb.FileOptions FileOptions.PyGenericServices
//   SourceCodeInfo.Location.Path: [4 10 2 9]
//   proto info: {}
func (t *FileOptions) GetPyGenericServices() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetPyGenericServices()

}

func (t *FileOptions) PyGenericServices() bool {
	return t.GetPyGenericServices()
}

//   See descriptorpb.FileOptions FileOptions.PhpGenericServices
//   SourceCodeInfo.Location.Path: [4 10 2 10]
//   proto info: {}
func (t *FileOptions) GetPhpGenericServices() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetPhpGenericServices()

}

func (t *FileOptions) PhpGenericServices() bool {
	return t.GetPhpGenericServices()
}

// Is this file deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for everything in the file, or it will be completely ignored; in the very
// least, this is a formalization for deprecating files.
//   See descriptorpb.FileOptions FileOptions.Deprecated
//   SourceCodeInfo.Location.Path: [4 10 2 11]
//   proto info: {}
func (t *FileOptions) GetDeprecated() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetDeprecated()

}

func (t *FileOptions) Deprecated() bool {
	return t.GetDeprecated()
}

// Enables the use of arenas for the proto messages in this file. This applies
// only to generated classes for C++.
//   See descriptorpb.FileOptions FileOptions.CcEnableArenas
//   SourceCodeInfo.Location.Path: [4 10 2 12]
//   proto info: {}
func (t *FileOptions) GetCcEnableArenas() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetCcEnableArenas()

}

func (t *FileOptions) CcEnableArenas() bool {
	return t.GetCcEnableArenas()
}

// Sets the objective c class prefix which is prepended to all objective c
// generated classes from this .proto. There is no default.
//   See descriptorpb.FileOptions FileOptions.ObjcClassPrefix
//   SourceCodeInfo.Location.Path: [4 10 2 13]
//   proto info: {}
func (t *FileOptions) GetObjcClassPrefix() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetObjcClassPrefix()

}

func (t *FileOptions) ObjcClassPrefix() string {
	return t.GetObjcClassPrefix()
}

// Namespace for generated classes; defaults to the package.
//   See descriptorpb.FileOptions FileOptions.CsharpNamespace
//   SourceCodeInfo.Location.Path: [4 10 2 14]
//   proto info: {}
func (t *FileOptions) GetCsharpNamespace() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetCsharpNamespace()

}

func (t *FileOptions) CsharpNamespace() string {
	return t.GetCsharpNamespace()
}

// By default Swift generators will take the proto package and CamelCase it
// replacing '.' with underscore and use that to prefix the types/symbols
// defined. When this options is provided, they will use this value instead
// to prefix the types/symbols defined.
//   See descriptorpb.FileOptions FileOptions.SwiftPrefix
//   SourceCodeInfo.Location.Path: [4 10 2 15]
//   proto info: {}
func (t *FileOptions) GetSwiftPrefix() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetSwiftPrefix()

}

func (t *FileOptions) SwiftPrefix() string {
	return t.GetSwiftPrefix()
}

// Sets the php class prefix which is prepended to all php generated classes
// from this .proto. Default is empty.
//   See descriptorpb.FileOptions FileOptions.PhpClassPrefix
//   SourceCodeInfo.Location.Path: [4 10 2 16]
//   proto info: {}
func (t *FileOptions) GetPhpClassPrefix() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetPhpClassPrefix()

}

func (t *FileOptions) PhpClassPrefix() string {
	return t.GetPhpClassPrefix()
}

// Use this option to change the namespace of php generated classes. Default
// is empty. When this option is empty, the package name will be used for
// determining the namespace.
//   See descriptorpb.FileOptions FileOptions.PhpNamespace
//   SourceCodeInfo.Location.Path: [4 10 2 17]
//   proto info: {}
func (t *FileOptions) GetPhpNamespace() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetPhpNamespace()

}

func (t *FileOptions) PhpNamespace() string {
	return t.GetPhpNamespace()
}

// Use this option to change the namespace of php generated metadata classes.
// Default is empty. When this option is empty, the proto file name will be
// used for determining the namespace.
//   See descriptorpb.FileOptions FileOptions.PhpMetadataNamespace
//   SourceCodeInfo.Location.Path: [4 10 2 18]
//   proto info: {}
func (t *FileOptions) GetPhpMetadataNamespace() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetPhpMetadataNamespace()

}

func (t *FileOptions) PhpMetadataNamespace() string {
	return t.GetPhpMetadataNamespace()
}

// Use this option to change the package of ruby generated classes. Default
// is empty. When this option is not set, the package name will be used for
// determining the ruby package.
//   See descriptorpb.FileOptions FileOptions.RubyPackage
//   SourceCodeInfo.Location.Path: [4 10 2 19]
//   proto info: {}
func (t *FileOptions) GetRubyPackage() (ret string) {
	if t.Empty() {
		return
	}

	return t.pb.GetRubyPackage()

}

func (t *FileOptions) RubyPackage() string {
	return t.GetRubyPackage()
}

// The parser stores options it doesn't recognize here.
// See the documentation for the "Options" section above.
//   See descriptorpb.FileOptions FileOptions.UninterpretedOption
//   SourceCodeInfo.Location.Path: [4 10 2 20]
//   proto info: {}
func (t *FileOptions) GetUninterpretedOption() (ret []*UninterpretedOption) {
	if t.Empty() {
		return
	}

	if t.uninterpreted_option != nil {
		return t.uninterpreted_option
	}

	t.uninterpreted_option = make([]*UninterpretedOption, len(t.pb.GetUninterpretedOption()))

	for i, item := range t.pb.GetUninterpretedOption() {
		elem := newUninterpretedOption(item)
		elem.setParent(t)
		elem.setIndex(i)
		t.uninterpreted_option[i] = elem
	}

	return t.uninterpreted_option

}

func (t *FileOptions) UninterpretedOption() []*UninterpretedOption {
	return t.GetUninterpretedOption()
}

func (t *FileOptions) PbDescriptor() *descriptorpb.FileOptions {
	if t == nil || t.pb == nil {
		return nil
	}
	return t.pb
}

func (t *FileOptions) FileOptions() *descriptorpb.FileOptions {
	return t.PbDescriptor()
}

/*
func (t *FileOptions) MarshalJSON() (b []byte,err error) {
    if t.Empty() {
        return
    }
    buf := bytes.NewBuffer(nil)
    err = (&jsonpb.Marshaler{}).Marshal(buf, t.pb)
    return buf.Bytes(), err
}
*/

// ExportFields returns can export fields
func (t *FileOptions) ExportFields() map[string]interface{} {
	return map[string]interface{}{
		"JavaPackage":               t.JavaPackage(),
		"JavaOuterClassname":        t.JavaOuterClassname(),
		"JavaMultipleFiles":         t.JavaMultipleFiles(),
		"JavaGenerateEqualsAndHash": t.JavaGenerateEqualsAndHash(),
		"JavaStringCheckUtf8":       t.JavaStringCheckUtf8(),
		"OptimizeFor":               t.OptimizeFor(),
		"GoPackage":                 t.GoPackage(),
		"CcGenericServices":         t.CcGenericServices(),
		"JavaGenericServices":       t.JavaGenericServices(),
		"PyGenericServices":         t.PyGenericServices(),
		"PhpGenericServices":        t.PhpGenericServices(),
		"Deprecated":                t.Deprecated(),
		"CcEnableArenas":            t.CcEnableArenas(),
		"ObjcClassPrefix":           t.ObjcClassPrefix(),
		"CsharpNamespace":           t.CsharpNamespace(),
		"SwiftPrefix":               t.SwiftPrefix(),
		"PhpClassPrefix":            t.PhpClassPrefix(),
		"PhpNamespace":              t.PhpNamespace(),
		"PhpMetadataNamespace":      t.PhpMetadataNamespace(),
		"RubyPackage":               t.RubyPackage(),
		"UninterpretedOption":       t.UninterpretedOption(),
	}
}

// implement DescriptorCommon.Empty()
func (t *FileOptions) Empty() bool {
	return t == nil || t.pb == nil
}

// implement DescriptorCommon.Index()
func (t *FileOptions) Index() int {
	if t.Empty() {
		return -1
	}

	return t.getIndex()
}

// implement DescriptorCommon.File()
func (t *FileOptions) File() *FileDescriptorProto {
	if t.Empty() {
		return nil
	}

	return t.getFile()
}

// implement DescriptorCommon.Parent()
func (t *FileOptions) Parent() DescriptorCommon {
	if t.Empty() {
		return nil
	}

	return t.getParent()
}

// implement DescriptorCommon.LocationPath()
func (t *FileOptions) LocationPath() LocationPath {
	if t.Empty() {
		return nil
	}

	return t.getLocationPath()
}

func (t *FileOptions) Comments() *SourceCodeInfo_Location {
	if t.Empty() {
		return nil
	}
	return t.getComments()
}
