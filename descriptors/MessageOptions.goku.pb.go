// Code generated by protoc-gen-goku. DO NOT EDIT.
// source: google/protobuf/descriptor.proto

package descriptors

import (
	"google.golang.org/protobuf/types/descriptorpb"
)

//   See: descriptorpb.MessageOptions
type MessageOptions struct {
	common

	pb *descriptorpb.MessageOptions

	uninterpreted_option []*UninterpretedOption
}

func newMessageOptions(desc *descriptorpb.MessageOptions) *MessageOptions {
	t := new(MessageOptions)
	t.pb = desc

	t.setDescriptor(t)

	return t
}

// Set true to use the old proto1 MessageSet wire format for extensions.
// This is provided for backwards-compatibility with the MessageSet wire
// format.  You should not use this for any other reason:  It's less
// efficient, has fewer features, and is more complicated.
//
// The message must be defined exactly as follows:
// message Foo {
// option message_set_wire_format = true;
// extensions 4 to max;
// }
// Note that the message cannot have any defined fields; MessageSets only
// have extensions.
//
// All extensions of your type must be singular messages; e.g. they cannot
// be int32s, enums, or repeated messages.
//
// Because this is an option, the above two restrictions are not enforced by
// the protocol compiler.
//   See descriptorpb.MessageOptions MessageOptions.MessageSetWireFormat
//   SourceCodeInfo.Location.Path: [4 11 2 0]
//   proto info: {}
func (t *MessageOptions) GetMessageSetWireFormat() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetMessageSetWireFormat()

}

func (t *MessageOptions) MessageSetWireFormat() bool {
	return t.GetMessageSetWireFormat()
}

// Disables the generation of the standard "descriptor()" accessor, which can
// conflict with a field of the same name.  This is meant to make migration
// from proto1 easier; new code should avoid fields named "descriptor".
//   See descriptorpb.MessageOptions MessageOptions.NoStandardDescriptorAccessor
//   SourceCodeInfo.Location.Path: [4 11 2 1]
//   proto info: {}
func (t *MessageOptions) GetNoStandardDescriptorAccessor() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetNoStandardDescriptorAccessor()

}

func (t *MessageOptions) NoStandardDescriptorAccessor() bool {
	return t.GetNoStandardDescriptorAccessor()
}

// Is this message deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for the message, or it will be completely ignored; in the very least,
// this is a formalization for deprecating messages.
//   See descriptorpb.MessageOptions MessageOptions.Deprecated
//   SourceCodeInfo.Location.Path: [4 11 2 2]
//   proto info: {}
func (t *MessageOptions) GetDeprecated() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetDeprecated()

}

func (t *MessageOptions) Deprecated() bool {
	return t.GetDeprecated()
}

// Whether the message is an automatically generated map entry type for the
// maps field.
//
// For maps fields:
// map<KeyType, ValueType> map_field = 1;
// The parsed descriptor looks like:
// message MapFieldEntry {
// option map_entry = true;
// optional KeyType key = 1;
// optional ValueType value = 2;
// }
// repeated MapFieldEntry map_field = 1;
//
// Implementations may choose not to generate the map_entry=true message, but
// use a native map in the target language to hold the keys and values.
// The reflection APIs in such implementations still need to work as
// if the field is a repeated message field.
//
// NOTE: Do not set the option in .proto files. Always use the maps syntax
// instead. The option should only be implicitly set by the proto compiler
// parser.
//   See descriptorpb.MessageOptions MessageOptions.MapEntry
//   SourceCodeInfo.Location.Path: [4 11 2 3]
//   proto info: {}
func (t *MessageOptions) GetMapEntry() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetMapEntry()

}

func (t *MessageOptions) MapEntry() bool {
	return t.GetMapEntry()
}

// The parser stores options it doesn't recognize here. See above.
//   See descriptorpb.MessageOptions MessageOptions.UninterpretedOption
//   SourceCodeInfo.Location.Path: [4 11 2 4]
//   proto info: {}
func (t *MessageOptions) GetUninterpretedOption() (ret []*UninterpretedOption) {
	if t.Empty() {
		return
	}

	if t.uninterpreted_option != nil {
		return t.uninterpreted_option
	}

	t.uninterpreted_option = make([]*UninterpretedOption, len(t.pb.GetUninterpretedOption()))

	for i, item := range t.pb.GetUninterpretedOption() {
		elem := newUninterpretedOption(item)
		elem.setParent(t)
		elem.setIndex(i)
		t.uninterpreted_option[i] = elem
	}

	return t.uninterpreted_option

}

func (t *MessageOptions) UninterpretedOption() []*UninterpretedOption {
	return t.GetUninterpretedOption()
}

func (t *MessageOptions) PbDescriptor() *descriptorpb.MessageOptions {
	if t == nil || t.pb == nil {
		return nil
	}
	return t.pb
}

func (t *MessageOptions) MessageOptions() *descriptorpb.MessageOptions {
	return t.PbDescriptor()
}

/*
func (t *MessageOptions) MarshalJSON() (b []byte,err error) {
    if t.Empty() {
        return
    }
    buf := bytes.NewBuffer(nil)
    err = (&jsonpb.Marshaler{}).Marshal(buf, t.pb)
    return buf.Bytes(), err
}
*/

// ExportFields returns can export fields
func (t *MessageOptions) ExportFields() map[string]interface{} {
	return map[string]interface{}{
		"MessageSetWireFormat":         t.MessageSetWireFormat(),
		"NoStandardDescriptorAccessor": t.NoStandardDescriptorAccessor(),
		"Deprecated":                   t.Deprecated(),
		"MapEntry":                     t.MapEntry(),
		"UninterpretedOption":          t.UninterpretedOption(),
	}
}

// implement DescriptorCommon.Empty()
func (t *MessageOptions) Empty() bool {
	return t == nil || t.pb == nil
}

// implement DescriptorCommon.Index()
func (t *MessageOptions) Index() int {
	if t.Empty() {
		return -1
	}

	return t.getIndex()
}

// implement DescriptorCommon.File()
func (t *MessageOptions) File() *FileDescriptorProto {
	if t.Empty() {
		return nil
	}

	return t.getFile()
}

// implement DescriptorCommon.Parent()
func (t *MessageOptions) Parent() DescriptorCommon {
	if t.Empty() {
		return nil
	}

	return t.getParent()
}

// implement DescriptorCommon.LocationPath()
func (t *MessageOptions) LocationPath() LocationPath {
	if t.Empty() {
		return nil
	}

	return t.getLocationPath()
}

func (t *MessageOptions) Comments() *SourceCodeInfo_Location {
	if t.Empty() {
		return nil
	}
	return t.getComments()
}
