// Code generated by protoc-gen-goku. DO NOT EDIT.
// source: google/protobuf/descriptor.proto

package descriptors

import (
	bytes "bytes"
	jsonpb "github.com/gogo/protobuf/jsonpb"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
)

//   See: descriptorpb.FieldOptions
type FieldOptions struct {
	common

	pb *descriptorpb.FieldOptions

	uninterpreted_option []*UninterpretedOption
}

func newFieldOptions(desc *descriptorpb.FieldOptions) *FieldOptions {
	t := new(FieldOptions)
	t.pb = desc

	t.setDescriptor(t)

	return t
}

// The ctype option instructs the C++ code generator to use a different
// representation of the field than it normally would.  See the specific
// options below.  This option is not yet implemented in the open source
// release -- sorry, we'll try to include it in a future version!
//   See descriptorpb.FieldOptions FieldOptions.Ctype
//   SourceCodeInfo.Location.Path: [4 12 2 0]
//   proto info: {"name":"ctype","number":1,"label":"LABEL_OPTIONAL","type":"TYPE_ENUM","typeName":".google.protobuf.FieldOptions.CType","defaultValue":"STRING","jsonName":"ctype"}
func (t *FieldOptions) GetCtype() (ret FieldOptions_CType) {
	if t.Empty() {
		return
	}

	return t.pb.GetCtype()

}

func (t *FieldOptions) Ctype() FieldOptions_CType {
	return t.GetCtype()
}

// The packed option can be enabled for repeated primitive fields to enable
// a more efficient representation on the wire. Rather than repeatedly
// writing the tag and type for each element, the entire array is encoded as
// a single length-delimited blob. In proto3, only explicit setting it to
// false will avoid using packed encoding.
//   See descriptorpb.FieldOptions FieldOptions.Packed
//   SourceCodeInfo.Location.Path: [4 12 2 1]
//   proto info: {"name":"packed","number":2,"label":"LABEL_OPTIONAL","type":"TYPE_BOOL","jsonName":"packed"}
func (t *FieldOptions) GetPacked() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetPacked()

}

func (t *FieldOptions) Packed() bool {
	return t.GetPacked()
}

// The jstype option determines the JavaScript type used for values of the
// field.  The option is permitted only for 64 bit integral and fixed types
// (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
// is represented as JavaScript string, which avoids loss of precision that
// can happen when a large value is converted to a floating point JavaScript.
// Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
// use the JavaScript "number" type.  The behavior of the default option
// JS_NORMAL is implementation dependent.
//
// This option is an enum to permit additional types to be added, e.g.
// goog.math.Integer.
//   See descriptorpb.FieldOptions FieldOptions.Jstype
//   SourceCodeInfo.Location.Path: [4 12 2 2]
//   proto info: {"name":"jstype","number":6,"label":"LABEL_OPTIONAL","type":"TYPE_ENUM","typeName":".google.protobuf.FieldOptions.JSType","defaultValue":"JS_NORMAL","jsonName":"jstype"}
func (t *FieldOptions) GetJstype() (ret FieldOptions_JSType) {
	if t.Empty() {
		return
	}

	return t.pb.GetJstype()

}

func (t *FieldOptions) Jstype() FieldOptions_JSType {
	return t.GetJstype()
}

// Should this field be parsed lazily?  Lazy applies only to message-type
// fields.  It means that when the outer message is initially parsed, the
// inner message's contents will not be parsed but instead stored in encoded
// form.  The inner message will actually be parsed when it is first accessed.
//
// This is only a hint.  Implementations are free to choose whether to use
// eager or lazy parsing regardless of the value of this option.  However,
// setting this option true suggests that the protocol author believes that
// using lazy parsing on this field is worth the additional bookkeeping
// overhead typically needed to implement it.
//
// This option does not affect the public interface of any generated code;
// all method signatures remain the same.  Furthermore, thread-safety of the
// interface is not affected by this option; const methods remain safe to
// call from multiple threads concurrently, while non-const methods continue
// to require exclusive access.
//
//
// Note that implementations may choose not to check required fields within
// a lazy sub-message.  That is, calling IsInitialized() on the outer message
// may return true even if the inner message has missing required fields.
// This is necessary because otherwise the inner message would have to be
// parsed in order to perform the check, defeating the purpose of lazy
// parsing.  An implementation which chooses not to check required fields
// must be consistent about it.  That is, for any particular sub-message, the
// implementation must either *always* check its required fields, or *never*
// check its required fields, regardless of whether or not the message has
// been parsed.
//   See descriptorpb.FieldOptions FieldOptions.Lazy
//   SourceCodeInfo.Location.Path: [4 12 2 3]
//   proto info: {"name":"lazy","number":5,"label":"LABEL_OPTIONAL","type":"TYPE_BOOL","defaultValue":"false","jsonName":"lazy"}
func (t *FieldOptions) GetLazy() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetLazy()

}

func (t *FieldOptions) Lazy() bool {
	return t.GetLazy()
}

// Is this field deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for accessors, or it will be completely ignored; in the very least, this
// is a formalization for deprecating fields.
//   See descriptorpb.FieldOptions FieldOptions.Deprecated
//   SourceCodeInfo.Location.Path: [4 12 2 4]
//   proto info: {"name":"deprecated","number":3,"label":"LABEL_OPTIONAL","type":"TYPE_BOOL","defaultValue":"false","jsonName":"deprecated"}
func (t *FieldOptions) GetDeprecated() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetDeprecated()

}

func (t *FieldOptions) Deprecated() bool {
	return t.GetDeprecated()
}

// For Google-internal migration only. Do not use.
//   See descriptorpb.FieldOptions FieldOptions.Weak
//   SourceCodeInfo.Location.Path: [4 12 2 5]
//   proto info: {"name":"weak","number":10,"label":"LABEL_OPTIONAL","type":"TYPE_BOOL","defaultValue":"false","jsonName":"weak"}
func (t *FieldOptions) GetWeak() (ret bool) {
	if t.Empty() {
		return
	}

	return t.pb.GetWeak()

}

func (t *FieldOptions) Weak() bool {
	return t.GetWeak()
}

// The parser stores options it doesn't recognize here. See above.
//   See descriptorpb.FieldOptions FieldOptions.UninterpretedOption
//   SourceCodeInfo.Location.Path: [4 12 2 6]
//   proto info: {"name":"uninterpreted_option","number":999,"label":"LABEL_REPEATED","type":"TYPE_MESSAGE","typeName":".google.protobuf.UninterpretedOption","jsonName":"uninterpretedOption"}
func (t *FieldOptions) GetUninterpretedOption() (ret []*UninterpretedOption) {
	if t.Empty() {
		return
	}

	if t.uninterpreted_option != nil {
		return t.uninterpreted_option
	}

	t.uninterpreted_option = make([]*UninterpretedOption, len(t.pb.GetUninterpretedOption()))

	for i, item := range t.pb.GetUninterpretedOption() {
		elem := newUninterpretedOption(item)
		elem.setParent(t)
		elem.setIndex(i)
		t.uninterpreted_option[i] = elem
	}

	return t.uninterpreted_option

}

func (t *FieldOptions) UninterpretedOption() []*UninterpretedOption {
	return t.GetUninterpretedOption()
}

func (t *FieldOptions) PbDescriptor() *descriptorpb.FieldOptions {
	if t == nil || t.pb == nil {
		return nil
	}
	return t.pb
}

func (t *FieldOptions) FieldOptions() *descriptorpb.FieldOptions {
	return t.PbDescriptor()
}

func (t *FieldOptions) MarshalJSON() (b []byte, err error) {
	if t.Empty() {
		return
	}
	buf := bytes.NewBuffer(nil)
	err = (&jsonpb.Marshaler{}).Marshal(buf, t.pb)
	return buf.Bytes(), err
}

// implement DescriptorCommon.Empty()
func (t *FieldOptions) Empty() bool {
	return t == nil || t.pb == nil
}

// implement DescriptorCommon.Index()
func (t *FieldOptions) Index() int {
	if t.Empty() {
		return -1
	}

	return t.getIndex()
}

// implement DescriptorCommon.File()
func (t *FieldOptions) File() *FileDescriptorProto {
	if t.Empty() {
		return nil
	}

	return t.getFile()
}

// implement DescriptorCommon.Parent()
func (t *FieldOptions) Parent() DescriptorCommon {
	if t.Empty() {
		return nil
	}

	return t.getParent()
}

// implement DescriptorCommon.LocationPath()
func (t *FieldOptions) LocationPath() LocationPath {
	if t.Empty() {
		return nil
	}

	return t.getLocationPath()
}
